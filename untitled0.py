# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18pAySNKfsrtt8ddp8hN-gbc-bTHyNbxW
"""

import pandas as pd
import random
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# Step 1: Data Creation (Product and User Interaction Data)
# Product Data (100 products with additional features)
product_data = pd.DataFrame({
    'product_id': [f'prod_{i}' for i in range(101, 201)],
    'category': [random.choice(['Vegetables', 'Fruits', 'Dairy', 'Meat']) for _ in range(100)],
    'sales': [random.randint(100, 2000) for _ in range(100)],
    'rating': [round(random.uniform(3.5, 5.0), 1) for _ in range(100)],
    'review_count': [random.randint(50, 500) for _ in range(100)],
    'views': [random.randint(500, 8000) for _ in range(100)],
    'added_to_cart': [random.randint(100, 500) for _ in range(100)],
    'wishlist_adds_product': [random.randint(50, 400) for _ in range(100)]  # Global wishlist adds
})

# User Interaction Data (500 users interacting with products)
user_interaction_data = pd.DataFrame({
    'user_id': [f'user_{i:03d}' for i in range(1, 501)],
    'product_id': [random.choice(product_data['product_id'].values) for _ in range(500)],
    'view': [random.randint(0, 20) for _ in range(500)],
    'add_to_cart': [random.randint(0, 5) for _ in range(500)],
    'wishlist_adds_user': [random.randint(0, 3) for _ in range(500)],  # User-specific wishlist adds
    'purchase': [random.randint(0, 1) for _ in range(500)],
    'timestamp': pd.date_range(start='2024-12-01', periods=500, freq='H').strftime('%Y-%m-%d %H:%M:%S').tolist()
})

# Step 2: Calculate Interaction Scores based on User Activity
view_weight = 1
add_to_cart_weight = 3
wishlist_add_weight = 2
purchase_weight = 5

user_interaction_data['interaction_score'] = (
    user_interaction_data['view'] * view_weight +
    user_interaction_data['add_to_cart'] * add_to_cart_weight +
    user_interaction_data['wishlist_adds_user'] * wishlist_add_weight +
    user_interaction_data['purchase'] * purchase_weight
)

# Step 3: Merge DataFrames and Normalize Features
merged_data = pd.merge(user_interaction_data, product_data, on='product_id', suffixes=('_user', '_product'))

# Normalize product interaction features
scaler = StandardScaler()
features_to_scale = ['sales', 'rating', 'review_count', 'views', 'added_to_cart', 'wishlist_adds_user']
merged_data[features_to_scale] = scaler.fit_transform(merged_data[features_to_scale])

# Prepare for training model (User-Product Interaction Matrix)
X = merged_data[['sales', 'rating', 'review_count', 'views', 'added_to_cart', 'wishlist_adds_user']]
y = merged_data['interaction_score']

# Split into training and testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 4: Train Random Forest Model for Collaborative Filtering
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Predictions and Metrics
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f'Mean Squared Error: {mse}')
print(f'R-squared: {r2}')

# Step 5: Feature Importance Plot
importances = rf_model.feature_importances_
indices = sorted(range(len(importances)), key=lambda i: importances[i], reverse=True)
features_sorted = X.columns[indices]

plt.figure(figsize=(10, 6))
plt.barh(features_sorted, importances[indices])
plt.xlabel('Importance')
plt.ylabel('Feature')
plt.title('Feature Importance - Random Forest')
plt.show()

# Step 6: Cosine Similarity for Content-Based Filtering
product_features = product_data[['category', 'sales', 'rating', 'review_count', 'views']]
product_features = pd.get_dummies(product_features, drop_first=True)
cosine_sim_content = cosine_similarity(product_features)

# Step 7: Hybrid Recommendation System

# Popularity-Based Recommendation
def popularity_based_recommendation(top_n=5):
    product_popularity = product_data.groupby('product_id').sum()['wishlist_adds_product']  # Global popularity (wishlist_adds_product)
    top_products = product_popularity.sort_values(ascending=False).head(top_n).index
    return product_data[product_data['product_id'].isin(top_products)][['product_id', 'rating']]

# Content-Based Recommendation
def content_based_recommendation(new_product_id, top_n=5):
    product_index = product_data[product_data['product_id'] == new_product_id].index[0]
    similar_products_content = cosine_sim_content[product_index]
    similar_product_indices_content = np.argsort(similar_products_content)[::-1][:top_n]
    return product_data.iloc[similar_product_indices_content]

# Collaborative Filtering Recommendation
def collaborative_filtering_recommendation(user_id, top_n=5):
    user_interactions = user_interaction_data[user_interaction_data['user_id'] == user_id]
    merged_user_data = pd.merge(user_interactions, product_data, on='product_id', how='left')
    user_features = merged_user_data[['sales', 'rating', 'review_count', 'views', 'added_to_cart', 'wishlist_adds_user']]
    user_scores = rf_model.predict(user_features)
    recommended_products_indices = np.argsort(user_scores)[::-1][:top_n]
    return product_data.iloc[recommended_products_indices]

# Hybrid Recommendation for New or Existing Users
def hybrid_recommendation(user_id=None, product_id=None, is_new_user=False, top_n=5, is_new_product=False):
    if is_new_user:
        # Recommend popular products for new users
        return popularity_based_recommendation(top_n=top_n)
    elif is_new_product:
        # Recommend new product based on content similarity
        return content_based_recommendation(product_id, top_n=top_n)
    elif product_id:
        # Product clicked, recommend similar products based on content
        return content_based_recommendation(product_id, top_n=top_n)
    else:
        # For existing users with historical data, recommend based on collaborative filtering
        return collaborative_filtering_recommendation(user_id, top_n=top_n)

# Example Scenarios
# Scenario 1: New User (Use Popularity-Based Recommendations)
print("Recommendations for New User:")
print(hybrid_recommendation(is_new_user=True, top_n=5))

# Scenario 2: Existing User Clicking on a Product
print("\nRecommendations for Existing User with Product Clicked:")
print(hybrid_recommendation(user_id='user_003', product_id='prod_110', top_n=5))

# Scenario 3: Existing User with Historical Data (Collaborative Filtering)
print("\nRecommendations for Existing User with Historical Data:")
print(hybrid_recommendation(user_id='user_003', is_new_user=False, top_n=5))

# Scenario 4: New Product Recommendation (Content-Based Filtering)
print("\nRecommendations for New Product:")
new_product_id = 'prod_150'  # Example of a newly added product
print(hybrid_recommendation(product_id=new_product_id, is_new_product=True, top_n=5))